### Что удалось добавить: 
Удалось создать метод выбора хода (choiceOrder()). Человеку предлагается выбрать, каким он хочет ходить: первым или вторым.

В методе main логика разделена на 2 части в зависимости от того, какая очередность выбрана.

Первый игрок ставит X, второй 0.

### Что получилось не до конца:
Придумал метод проверки победителя. Он заключается в том, что мы получаем координаты хода игрока (например [3][2]) и проверяем целиком строчку и столбик, соответствующие данным координатам, на наличие непрерывной комбинации крестика или нолика в количестве равной выйгрышной переменной WIN_COUNT.

Если мы получили координаты [3][2], то проверяем циклами 3 строку с первого элемента. По тому же принципу проверяем 2 столбик с самого верхнего элемента до самого нижнего. Цель: найти выйгрышную комбинацию.

Если брать поиск только по горизонтали и вертикали, получается, что мы не проходим по всему полю, а проверяем меньшее количество элементов. 

XOO**X**O

XXX**O**O

**XOOOX**

OOX**O**X

OXX**O**O

*Не получилось реализовать проверку по диагонали. Хотел сделать её по аналогичному принципу, но сталкнулся с тем, что нужно было бы добавлять ещё один цикл. И как всё это сделать правильно пока не понял!*